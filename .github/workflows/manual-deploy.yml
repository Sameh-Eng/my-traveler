name: ğŸš€ Manual Deploy to Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
        - development

      service:
        description: 'Service to Deploy'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - frontend
        - backend
        - monitoring

      version:
        description: 'Image Version (leave empty for latest)'
        required: false
        default: ''
        type: string

      skip_tests:
        description: 'Skip Tests (for emergency deployments)'
        required: false
        default: false
        type: boolean

      rollback:
        description: 'Rollback to Previous Version'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY_PREFIX: mytraveler

jobs:
  # =======================================
  # MANUAL DEPLOYMENT JOB
  # =======================================
  manual-deploy:
    name: ğŸš€ Manual Deploy (${{ github.event.inputs.environment }})
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      # =======================================
      # STEP 1: Checkout Repository
      # =======================================
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.version || 'main' }}

      # =======================================
      # STEP 2: Configure AWS Credentials
      # =======================================
      - name: ğŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # =======================================
      # STEP 3: Get Deployment Parameters
      # =======================================
      - name: ğŸ“‹ Get Deployment Parameters
        id: deploy-params
        run: |
          # Set environment-specific parameters
          case "${{ github.event.inputs.environment }}" in
            "production")
              ECS_CLUSTER=${{ secrets.PROD_ECS_CLUSTER }}
              ECS_SERVICE=${{ secrets.PROD_ECS_SERVICE }}
              LOAD_BALANCER=${{ secrets.PROD_LOAD_BALANCER }}
              ;;
            "staging")
              ECS_CLUSTER=${{ secrets.STAGING_ECS_CLUSTER }}
              ECS_SERVICE=${{ secrets.STAGING_ECS_SERVICE }}
              LOAD_BALANCER=${{ secrets.STAGING_LOAD_BALANCER }}
              ;;
            "development")
              ECS_CLUSTER=${{ secrets.DEV_ECS_CLUSTER }}
              ECS_SERVICE=${{ secrets.DEV_ECS_SERVICE }}
              LOAD_BALANCER=${{ secrets.DEV_LOAD_BALANCER }}
              ;;
          esac

          # Determine image version
          if [[ -z "${{ github.event.inputs.version }}" ]]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="${{ github.event.inputs.version }}"
          fi

          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "ecs-service=$ECS_SERVICE" >> $GITHUB_OUTPUT
          echo "load-balancer=$LOAD_BALANCER" >> $GITHUB_OUTPUT
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      # =======================================
      # STEP 4: Login to ECR
      # =======================================
      - name: ğŸ˜ Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # =======================================
      # STEP 5: Rollback Logic
      # =======================================
      - name: ğŸ”„ Rollback Deployment
        if: github.event.inputs.rollback == 'true'
        run: |
          echo "ğŸ”„ Initiating rollback to previous version..."

          # Get current service information
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ steps.deploy-params.outputs.ecs-cluster }} \
            --services ${{ steps.deploy-params.outputs.ecs-service }} \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "Current task definition: $CURRENT_TASK_DEF"

          # Get list of task definitions
          TASK_DEFS=$(aws ecs list-task-definitions \
            --family-prefix mytraveler-task \
            --sort DESC \
            --query 'taskDefinitionArns[1]' \
            --output text)

          echo "Rolling back to: $TASK_DEFS"

          # Update service with previous task definition
          aws ecs update-service \
            --cluster ${{ steps.deploy-params.outputs.ecs-cluster }} \
            --service ${{ steps.deploy-params.outputs.ecs-service }} \
            --task-definition $TASK_DEFS \
            --force-new-deployment

          echo "âœ… Rollback initiated successfully!"

      # =======================================
      # STEP 6: Build Images (if not rollback)
      # =======================================
      - name: ğŸ³ Build Frontend Image
        if: github.event.inputs.rollback != 'true' && (github.event.inputs.service == 'all' || github.event.inputs.service == 'frontend')
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ steps.deploy-params.outputs.image-tag }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ github.sha }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_PAYMOB_IFRAME=${{ secrets.NEXT_PUBLIC_PAYMOB_IFRAME }}
            NODE_ENV=production
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ğŸ³ Build Backend Image
        if: github.event.inputs.rollback != 'true' && (github.event.inputs.service == 'all' || github.event.inputs.service == 'backend')
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ steps.deploy-params.outputs.image-tag }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ github.sha }}
          build-args: |
            NODE_ENV=production
            APP_VERSION=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # =======================================
      # STEP 7: Generate ECS Task Definition
      # =======================================
      - name: ğŸ“„ Generate ECS Task Definition
        if: github.event.inputs.rollback != 'true'
        run: |
          # Create task definition with new image tags
          cat > ecs-task-definition.json << 'EOF'
          {
            "family": "mytraveler-task-${{ github.event.inputs.environment }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "${{ github.event.inputs.environment == 'production' && '1024' || '512' }}",
            "memory": "${{ github.event.inputs.environment == 'production' && '2048' || '1024' }}",
            "executionRoleArn": "${{ secrets.ECS_EXECUTION_ROLE_ARN }}",
            "taskRoleArn": "${{ secrets.ECS_TASK_ROLE_ARN }}",
            "containerDefinitions": [
          EOF

          # Add frontend container if selected
          if [[ "${{ github.event.inputs.service }}" == "all" ]] || [[ "${{ github.event.inputs.service }}" == "frontend" ]]; then
            cat >> ecs-task-definition.json << 'EOF'
              {
                "name": "frontend",
                "image": "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ steps.deploy-params.outputs.image-tag }}",
                "portMappings": [
                  {
                    "containerPort": 80,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "${{ github.event.inputs.environment }}"
                  }
                ],
                "secrets": [
                  {
                    "name": "NEXT_PUBLIC_API_URL",
                    "valueFrom": "${{ secrets.NEXT_PUBLIC_API_URL_ARN }}"
                  },
                  {
                    "name": "NEXT_PUBLIC_PAYMOB_IFRAME",
                    "valueFrom": "${{ secrets.NEXT_PUBLIC_PAYMOB_IFRAME_ARN }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/mytraveler-${{ github.event.inputs.environment }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs-frontend"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "essential": false,
                "dependsOn": [
                  {
                    "containerName": "backend",
                    "condition": "START"
                  }
                }
              },
          EOF
          fi

          # Always add backend container
          cat >> ecs-task-definition.json << 'EOF'
              {
                "name": "backend",
                "image": "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ steps.deploy-params.outputs.image-tag }}",
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "${{ github.event.inputs.environment }}"
                  },
                  {
                    "name": "PORT",
                    "value": "8080"
                  }
                ],
                "secrets": [
                  {
                    "name": "DB_HOST",
                    "valueFrom": "${{ github.event.inputs.environment == 'production' && secrets.DB_HOST_ARN_PROD || secrets.DB_HOST_ARN }}"
                  },
                  {
                    "name": "DB_NAME",
                    "valueFrom": "${{ github.event.inputs.environment == 'production' && secrets.DB_NAME_ARN_PROD || secrets.DB_NAME_ARN }}"
                  },
                  {
                    "name": "DB_USER",
                    "valueFrom": "${{ github.event.inputs.environment == 'production' && secrets.DB_USER_ARN_PROD || secrets.DB_USER_ARN }}"
                  },
                  {
                    "name": "DB_PASSWORD",
                    "valueFrom": "${{ github.event.inputs.environment == 'production' && secrets.DB_PASSWORD_ARN_PROD || secrets.DB_PASSWORD_ARN }}"
                  },
                  {
                    "name": "REDIS_HOST",
                    "valueFrom": "${{ secrets.REDIS_HOST_ARN }}"
                  },
                  {
                    "name": "REDIS_PASSWORD",
                    "valueFrom": "${{ secrets.REDIS_PASSWORD_ARN }}"
                  },
                  {
                    "name": "JWT_SECRET",
                    "valueFrom": "${{ secrets.JWT_SECRET_ARN }}"
                  },
                  {
                    "name": "PAYMOB_API_KEY",
                    "valueFrom": "${{ secrets.PAYMOB_API_KEY_ARN }}"
                  },
                  {
                    "name": "PAYMOB_INTEGRATION_ID",
                    "valueFrom": "${{ secrets.PAYMOB_INTEGRATION_ID_ARN }}"
                  },
                  {
                    "name": "PAYMOB_HMAC_KEY",
                    "valueFrom": "${{ secrets.PAYMOB_HMAC_KEY_ARN }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/mytraveler-${{ github.event.inputs.environment }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs-backend"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "essential": true
              }
            ]
          }
          EOF

      # =======================================
      # STEP 8: Register and Deploy
      # =======================================
      - name: ğŸ“ Register Task Definition
        id: register-task
        if: github.event.inputs.rollback != 'true'
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://ecs-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task-definition-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: ğŸš€ Deploy to ECS
        if: github.event.inputs.rollback != 'true'
        run: |
          # Update service with new task definition
          DESIRED_COUNT="${{ github.event.inputs.environment == 'production' && '2' || '1' }}"

          aws ecs update-service \
            --cluster ${{ steps.deploy-params.outputs.ecs-cluster }} \
            --service ${{ steps.deploy-params.outputs.ecs-service }} \
            --task-definition ${{ steps.register-task.outputs.task-definition-arn }} \
            --force-new-deployment \
            --desired-count $DESIRED_COUNT

          echo "â³ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ steps.deploy-params.outputs.ecs-cluster }} \
            --services ${{ steps.deploy-params.outputs.ecs-service }}

          echo "âœ… Service updated successfully!"

      # =======================================
      # STEP 9: Health Check
      # =======================================
      - name: ğŸ¥ Health Check Deployment
        run: |
          # Get load balancer DNS name
          LB_DNS=$(aws elbv2 describe-load-balancers \
            --names ${{ steps.deploy-params.outputs.load-balancer }} \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "ğŸŒ Application URL: http://$LB_DNS"
          echo "ğŸ“Š Monitoring URL: http://$LB_DNS:3001"

          # Wait for health check
          echo "â³ Waiting for health check to pass..."
          timeout 300 bash -c 'until curl -f http://$LB_DNS/health; do sleep 10; done'
          echo "âœ… Health check passed!"

      # =======================================
      # STEP 10: Notify
      # =======================================
      - name: ğŸ“± Send Deployment Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          text: |
            ğŸš€ MyTraveler Manual Deployment

            ğŸŒ Environment: ${{ github.event.inputs.environment }}
            ğŸ¯ Services: ${{ github.event.inputs.service }}
            ğŸ·ï¸ Version: ${{ github.event.inputs.version || 'latest' }}
            ğŸ”„ Rollback: ${{ github.event.inputs.rollback && 'Yes' || 'No' }}
            âš¡ Skip Tests: ${{ github.event.inputs.skip_tests && 'Yes' || 'No' }}

            ğŸŒ Live Site: http://$(aws elbv2 describe-load-balancers --names ${{ steps.deploy-params.outputs.load-balancer }} --query 'LoadBalancers[0].DNSName' --output text)
            ğŸ“Š Monitoring: http://$(aws elbv2 describe-load-balancers --names ${{ steps.deploy-params.outputs.load-balancer }} --query 'LoadBalancers[0].DNSName' --output text):3001

            ğŸ‘¤ Deployed by: ${{ github.actor }}
            ğŸ• Time: $(date -u)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}