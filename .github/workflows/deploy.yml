name: üöÄ Deploy to Production

on:
  push:
    branches: [main]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'Dockerfile.frontend'
      - 'backend/Dockerfile.prod'
      - '.github/workflows/deploy.yml'

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY_PREFIX: mytraveler

jobs:
  # =======================================
  # BUILD & TEST JOB
  # =======================================
  build-and-test:
    name: üî® Build & Test
    runs-on: ubuntu-latest

    # Environment variables
    env:
      NODE_ENV: test
      NEXT_PUBLIC_API_URL: http://localhost:8080
      DB_HOST: localhost
      DB_PORT: 5432
      DB_NAME: test_mytraveler
      DB_USER: test_user
      DB_PASSWORD: test_password

    services:
      # PostgreSQL for testing
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: ${{ env.DB_NAME }}
          POSTGRES_USER: ${{ env.DB_USER }}
          POSTGRES_PASSWORD: ${{ env.DB_PASSWORD }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        volumes:
          - ./backend/database/init:/docker-entrypoint-initdb.d:ro

      # Redis for testing
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        volumes:
          - redis_test_data:/data

    steps:
      # =======================================
      # STEP 1: Checkout Source Code
      # =======================================
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full git history for versioning
          submodules: recursive  # Include submodules if any

      # =======================================
      # STEP 2: Setup Node.js Environment
      # =======================================
      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            frontend/package-lock.json
            backend/package-lock.json

      # =======================================
      # STEP 3: Install Dependencies
      # =======================================
      - name: üì¶ Install Frontend Dependencies
        run: |
          cd frontend
          npm ci --prefer-offline --no-audit --no-fund

      - name: üì¶ Install Backend Dependencies
        run: |
          cd backend
          npm ci --prefer-offline --no-audit --no-fund

      # =======================================
      # STEP 4: Run Linting & Code Quality Checks
      # =======================================
      - name: üîç Lint Frontend Code
        run: |
          cd frontend
          npm run lint

      - name: üîç Lint Backend Code
        run: |
          cd backend
          npm run lint

      - name: üîç Security Audit
        run: |
          cd frontend && npm audit --audit-level moderate || true
          cd ../backend && npm audit --audit-level moderate || true

      # =======================================
      # STEP 5: Run Unit Tests
      # =======================================
      - name: üß™ Run Frontend Tests
        run: |
          cd frontend
          npm run test:coverage

      - name: üß™ Run Backend Tests
        run: |
          cd backend
          npm run test:coverage
        env:
          DATABASE_URL: postgresql://${{ env.DB_USER }}:${{ env.DB_PASSWORD }}@localhost:${{ env.DB_PORT }}/${{ env.DB_NAME }}
          REDIS_URL: redis://localhost:6379

      # =======================================
      # STEP 6: Build Applications
      # =======================================
      - name: üî® Build Frontend
        run: |
          cd frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_PAYMOB_IFRAME: ${{ secrets.NEXT_PUBLIC_PAYMOB_IFRAME }}

      - name: üî® Build Backend
        run: |
          cd backend
          npm run build
        env:
          NODE_ENV: production

      # =======================================
      # STEP 7: Upload Build Artifacts
      # =======================================
      - name: üì§ Upload Frontend Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/.next/
          retention-days: 7

      - name: üì§ Upload Backend Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend/dist/
          retention-days: 7

  # =======================================
  # DOCKER BUILD & PUSH JOB
  # =======================================
  docker-build-and-push:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: build-and-test

    permissions:
      contents: read
      packages: write

    steps:
      # =======================================
      # STEP 1: Checkout Source Code
      # =======================================
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # =======================================
      # STEP 2: Download Build Artifacts
      # =======================================
      - name: üì• Download Frontend Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/.next/

      - name: üì• Download Backend Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: backend/dist/

      # =======================================
      # STEP 3: Configure AWS Credentials
      # =======================================
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: true  # Hide account ID in logs

      # =======================================
      # STEP 4: Login to Amazon ECR
      # =======================================
      - name: üêò Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      # =======================================
      # STEP 5: Generate Docker Metadata
      # =======================================
      - name: üè∑Ô∏è Generate Docker Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend
          tags: |
            # Main branch tagging
            type=ref,event=branch,suffix=-${{ github.sha }}
            type=ref,event=branch,suffix=-latest
            # Semantic versioning (if available)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            # Commit SHA
            type=sha,prefix={{branch}}-
            # Pull request (for testing)
            type=ref,event=pr

      # =======================================
      # STEP 6: Build and Push Frontend Image
      # =======================================
      - name: üê≥ Build and Push Frontend Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ github.sha }},${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:latest
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_PAYMOB_IFRAME=${{ secrets.NEXT_PUBLIC_PAYMOB_IFRAME }}
            NODE_ENV=production
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64  # Multi-arch support

      # =======================================
      # STEP 7: Build and Push Backend Image
      # =======================================
      - name: üê≥ Build and Push Backend Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ github.sha }},${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:latest
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NODE_ENV=production
            APP_VERSION=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      # =======================================
      # STEP 8: Security Scan Images
      # =======================================
      - name: üîç Scan Frontend Image for Vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
          severity: 'HIGH,CRITICAL'

      - name: üì§ Upload Frontend Security Scan Results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-frontend-results.sarif'

      - name: üîç Scan Backend Image for Vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-backend-results.sarif'
          severity: 'HIGH,CRITICAL'

      - name: üì§ Upload Backend Security Scan Results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-backend-results.sarif'

  # =======================================
  # DEPLOY TO ECS JOB
  # =======================================
  deploy-to-ecs:
    name: üöÄ Deploy to ECS
    runs-on: ubuntu-latest
    needs: docker-build-and-push
    environment: production

    steps:
      # =======================================
      # STEP 1: Checkout Source Code
      # =======================================
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # =======================================
      # STEP 2: Configure AWS Credentials
      # =======================================
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # =======================================
      # STEP 3: Generate ECS Task Definition
      # =======================================
      - name: üìÑ Generate ECS Task Definition
        run: |
          # Create task definition with new image tags
          cat > ecs-task-definition.json << EOF
          {
            "family": "mytraveler-task",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "1024",
            "memory": "2048",
            "executionRoleArn": "${{ secrets.ECS_EXECUTION_ROLE_ARN }}",
            "taskRoleArn": "${{ secrets.ECS_TASK_ROLE_ARN }}",
            "containerDefinitions": [
              {
                "name": "frontend",
                "image": "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-frontend:${{ github.sha }}",
                "portMappings": [
                  {
                    "containerPort": 80,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  }
                ],
                "secrets": [
                  {
                    "name": "NEXT_PUBLIC_API_URL",
                    "valueFrom": "${{ secrets.NEXT_PUBLIC_API_URL_ARN }}"
                  },
                  {
                    "name": "NEXT_PUBLIC_PAYMOB_IFRAME",
                    "valueFrom": "${{ secrets.NEXT_PUBLIC_PAYMOB_IFRAME_ARN }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/mytraveler",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs-frontend"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "essential": false,
                "dependsOn": [
                  {
                    "containerName": "backend",
                    "condition": "START"
                  }
                ]
              },
              {
                "name": "backend",
                "image": "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-backend:${{ github.sha }}",
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "production"
                  },
                  {
                    "name": "PORT",
                    "value": "8080"
                  }
                ],
                "secrets": [
                  {
                    "name": "DB_HOST",
                    "valueFrom": "${{ secrets.DB_HOST_ARN }}"
                  },
                  {
                    "name": "DB_NAME",
                    "valueFrom": "${{ secrets.DB_NAME_ARN }}"
                  },
                  {
                    "name": "DB_USER",
                    "valueFrom": "${{ secrets.DB_USER_ARN }}"
                  },
                  {
                    "name": "DB_PASSWORD",
                    "valueFrom": "${{ secrets.DB_PASSWORD_ARN }}"
                  },
                  {
                    "name": "REDIS_HOST",
                    "valueFrom": "${{ secrets.REDIS_HOST_ARN }}"
                  },
                  {
                    "name": "REDIS_PASSWORD",
                    "valueFrom": "${{ secrets.REDIS_PASSWORD_ARN }}"
                  },
                  {
                    "name": "JWT_SECRET",
                    "valueFrom": "${{ secrets.JWT_SECRET_ARN }}"
                  },
                  {
                    "name": "PAYMOB_API_KEY",
                    "valueFrom": "${{ secrets.PAYMOB_API_KEY_ARN }}"
                  },
                  {
                    "name": "PAYMOB_INTEGRATION_ID",
                    "valueFrom": "${{ secrets.PAYMOB_INTEGRATION_ID_ARN }}"
                  },
                  {
                    "name": "PAYMOB_HMAC_KEY",
                    "valueFrom": "${{ secrets.PAYMOB_HMAC_KEY_ARN }}"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/mytraveler",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs-backend"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                },
                "essential": true
              }
            ]
          }
          EOF

      # =======================================
      # STEP 4: Register New Task Definition
      # =======================================
      - name: üìù Register ECS Task Definition
        id: register-task-definition
        run: |
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://ecs-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task-definition-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered task definition: $TASK_DEF_ARN"

      # =======================================
      # STEP 5: Update ECS Service
      # =======================================
      - name: üîÑ Update ECS Service
        id: update-service
        run: |
          # Update the service with new task definition
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_SERVICE_NAME }} \
            --task-definition ${{ steps.register-task-definition.outputs.task-definition-arn }} \
            --force-new-deployment \
            --desired-count 2

          # Wait for service to stabilize
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_SERVICE_NAME }}

          echo "Service updated successfully"

      # =======================================
      # STEP 6: Get New Service Details
      # =======================================
      - name: üìä Get Service Details
        run: |
          echo "=== ECS Service Status ==="
          aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_SERVICE_NAME }} \
            --query 'services[0].[status,runningCount,desiredCount,taskDefinition]' \
            --output table

          echo "=== Load Balancer DNS ==="
          aws elbv2 describe-load-balancers \
            --names ${{ secrets.LOAD_BALANCER_NAME }} \
            --query 'LoadBalancers[0].DNSName' \
            --output text

      # =======================================
      # STEP 7: Health Check Deployment
      # =======================================
      - name: üè• Health Check Deployment
        run: |
          # Get load balancer DNS name
          LB_DNS=$(aws elbv2 describe-load-balancers \
            --names ${{ secrets.LOAD_BALANCER_NAME }} \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "Performing health check on http://$LB_DNS"

          # Wait for health check to pass
          timeout 300 bash -c 'until curl -f http://$LB_DNS/health; do sleep 10; done'

          echo "‚úÖ Health check passed! Deployment is healthy."

      # =======================================
      # STEP 8: Notify Deployment Success
      # =======================================
      - name: üì¢ Notify Deployment Success
        if: success()
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üåê Application is available at: http://$(aws elbv2 describe-load-balancers --names ${{ secrets.LOAD_BALANCER_NAME }} --query 'LoadBalancers[0].DNSName' --output text)"
          echo "üìä Monitoring available at: http://$(aws elbv2 describe-load-balancers --names ${{ secrets.LOAD_BALANCER_NAME }} --query 'LoadBalancers[0].DNSName' --output text):3001"

      # =======================================
      # STEP 9: Rollback on Failure
      # =======================================
      - name: üîÑ Rollback on Failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed. Initiating rollback..."

          # Get previous task definition
          PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --services ${{ secrets.ECS_SERVICE_NAME }} \
            --query 'services[0].taskDefinition' \
            --output text)

          # Rollback to previous task definition
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER_NAME }} \
            --service ${{ secrets.ECS_SERVICE_NAME }} \
            --task-definition $PREVIOUS_TASK_DEF \
            --force-new-deployment

          echo "üîÑ Rollback initiated to previous task definition: $PREVIOUS_TASK_DEF"

  # =======================================
  # NOTIFICATION JOB
  # =======================================
  notify:
    name: üì¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-test, docker-build-and-push, deploy-to-ecs]
    if: always()

    steps:
      # =======================================
      # STEP 1: Send Slack Notification
      # =======================================
      - name: üì± Send Slack Notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          text: |
            üöÄ MyTraveler Deployment Status

            üì¶ Build & Test: ${{ needs.build-and-test.result }}
            üê≥ Docker Build: ${{ needs.docker-build-and-push.result }}
            üöÄ Deploy to ECS: ${{ needs.deploy-to-ecs.result }}

            üåê Live Site: http://${{ secrets.LOAD_BALANCER_DNS }}
            üìä Monitoring: http://${{ secrets.LOAD_BALANCER_DNS }}:3001

            üë§ Commit: ${{ github.sha }}
            üåø Branch: ${{ github.ref }}
            üë§ Author: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # =======================================
      # STEP 2: Update Deployment Status Badge
      # =======================================
      - name: üè∑Ô∏è Update Deployment Status
        if: always()
        run: |
          # Create deployment status badge (you can use shields.io or similar)
          echo "Deployment status: ${{ job.status }}"

          # Update GitHub deployment status
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }} \
            -d '{
              "state": "${{ job.status == 'success' && 'success' || 'failure' }}",
              "target_url": "http://${{ secrets.LOAD_BALANCER_DNS }}",
              "description": "Deployment to ECS ${{ job.status == 'success' && 'completed successfully' || 'failed' }}",
              "context": "ecs-deployment"
            }'

# =======================================
# WORKFLOW CONFIGURATION
# =======================================
concurrency:
  group: deploy-production
  cancel-in-progress: false  # Don't cancel ongoing deployments

# Global permissions
permissions:
  contents: read
  packages: write
  deployments: write
  statuses: write
  security-events: write

# Environment
environment:
  name: production
  url: http://${{ secrets.LOAD_BALANCER_DNS }}